\section{Upper bounds}

%The algorithms presented in this section iteratively construct broadcast foerest $T_i, i=1,2,\dots$.
The following inexact method is based on the idea of finding maximum cardinality matching in $G\left[V_{T_i},V\setminus V_{T_i}\right]$, and extending $T_i$ by this matching.
It means that in each iteration $i$, the maximum possible number of nodes are informed.
The maximum cardinality matching can be regarded as finding $|V_{T_i}|$ node-disjoint  binomial trees of order at most one with roots in $V_{T_i}$, maximizing the number of edges.
By generalizing this notion, we iteratively look for $|V_{T_i}|$ node-disjoint (pruned) binomial trees of an arbitrary given order $k$ valued between 1 and $n-|S|$.
Even though this problem is NP-hard for $k\geq 2$ \cite{jansen95}, it is expected that the computational time is sound in most practical instances.
After obtaining the set of binomial trees, first $p$ nodes in each tree are selected and added to the broadcast forest.
The parameter $p\in \{1,\dots,2^k\}$ is also a part of the input.
\begin{algorithm}[]
\KwData{$G=(V,E), S\subseteq V, k\in \{1,\dots,n-|S|\}, p\in \{1,\dots,2^k\}$}
\textbf{for }$s\in S\textbf{ do }T_s=(V_s,A_s), V_s\leftarrow \{s\}, E_s\leftarrow\emptyset$\;
$I=\{1,\dots,2^k\}$\\
$T=\{T_s:s\in S\}$\ ~~~\tcp{broadcast forest}
$t\leftarrow 0$\;
\While{$V_T\neq V$} {
	$S\leftarrow V_T$\;
	Find a set of pruned binomial trees $B=\{B_1,\dots,B_{|V_T|}\}$ of order at most $k$ with roots in $V_T$ by solving model \eqref{mod:genmatch}\;
	$V_T\leftarrow V_T\cup \{v:v\in V_B:\beta(v)\leq p\}$\;
	$E_T\leftarrow E_T\cup \{\{u,v\}\in E_B: \beta(u)\leq p,\beta(v)\leq p\}$\;
	$t\leftarrow t+1$\;
}
\Return t\;
%\Return $\lceil k/s \rceil$\;
 \caption{A method for determining an upper bound}
\label{alg:match}
\end{algorithm}

Alg. \ref{alg:match} describes the process formally.
Initially, the broadcast forest consists of isolated sources.
The binomial trees are determined by solving the ILP model \eqref{mod:genmatch}. 
This model is a modification of formulation \eqref{mod:partition}, and uses the same type of variables.
The objective function is to maximize the number of nodes involved in the binomial trees.
%The index set $I=\{1,\dots,2^k\}$ depends on the input parameter $k$.
The constraints \eqref{mod:genmatch:nodeBelongs} state that each node belongs to at most one binomial tree.
Compared to \eqref{mod:part:nodeBelongs}, \eqref{mod:genmatch:nodeBelongs} is an inequality, because the binomial trees do not necessarily form a partition of $G$, and so not all nodes have to be used.
The remaining constraints are taken from formulation \eqref{mod:partition}. 
Note that in every iteration, the model is solved with a different set $S$, as all nodes already included in the broadcast forest are roots of the binomial trees.
The model considers the entire set $V$, but it is also possible to restrict this set to nodes with distance at most $k$ from some node in $V_T$.
When this restriction is not imposed, nodes with larger distance are not a part of any binomial tree in the current iteration due to \eqref{mod:part:followArcsA} - \eqref{mod:part:followArcsB}.

\begin{subequations}\label{mod:genmatch}
\begin{align}
\notag \max\sum\limits_{v\in V}&\sum\limits_{i\in I}\sum\limits_{s\in S}   y_{is}^v,\\
\notag \text{s. t. } \\
\label{mod:genmatch:nodeBelongs} \sum\limits_{i\in I}\sum\limits_{s\in S}y^v_{is} & \leq 1 & v\in V,\\
\notag\eqref{mod:part:treeHasIJ} - \eqref{mod:part:followArcsB},\\
%\label{mod:genmatch:treeHasIJ} \sum\limits_{v\in V'}y^v_{is} & = 1 & i\in I,s\in V_T,\\
%\label{mod:genmatch:source1} y_{1s}^s & = 1  & s\in V_T,\\
%\label{mod:part:noReturn} y^u_{ij}+y^v_{lj} &\leq 1 & i\in I,l\in C(i), j\in J, u\in V_\alpha,v\in V,\\
%\label{mod:part:followArcs} y^u_{is}+y^v_{\ell s} &\leq 1 & i\in I,\ell\in C(i), s\in S, u,v\in V',(u,v)\not\in A',\\
%\label{mod:part:followArcsA} y^u_{is}+y^v_{\ell s} &\leq 1 & i\in I,\ell\in C(i), s\in S, u,v\in V,\{u,v\}\not\in E,\\
%\label{mod:part:followArcsB} y^{v_0}_{is}+y^v_{\ell s} &\leq 1 & i\in I,\ell\in C(i), s\in S, v\in V,\\
%\label{mod:genmatch:followArcsA}y^{v_0}_{is}+y^u_{i s} + \sum\limits_{v\in V\setminus N(u)}y^v_{\ell s}&\leq 1 & u\in V,i\in I,\ell\in C(i), s\in V_T,  \\
%\label{mod:genmatch:followArcsB}y^{v_0}_{is}+y^u_{\ell s} + \sum\limits_{v\in V\setminus N(u)}y^v_{i s}&\leq 1 & u\in V,i\in I,\ell\in C(i), s\in V_T,\\ 
\label{mod:genmatch:dim}&&y \in \{0,1\}^{I\times S\times V'}.
\end{align}~
\end{subequations}



%
%We present a simple general method for determining an upper bound on the optimal solution.
%The idea is to construct broadcast trees in parallel from their roots in sources.
%A new node is connected to a tree is it was not connected to any other tree in any of the previous iterations.
%The steps are summarized in Alg. \ref{alg:genub}.
%
%\begin{algorithm}[]
%\KwData{$G=(V,E), S\subseteq V$}
%$U\leftarrow S$;\tcp{Set of marked nodes}
%$T_s=(V_s,A_s), V_s\leftarrow \{s\}, E_s\leftarrow\emptyset$\;
%\While{$|U|<n$} {
%	\For{$s\in S$} {
%		Select $v\in V\setminus U:\exists u\in V_s \text{ s. t.} \{u,v\}\in E$ according to some strategy\; 	
%		$U\leftarrow U\cup\{v\}$\;
%		$V_s\leftarrow V_s\cup\{v\}$\;
%		$A_s\leftarrow A_s\cup\{u,v\}$\;
%	}
%}
%\For{$s\in S$} {
%$	
%\sigma(v)=\begin{cases}
%		0, \text{ if } v\in L(T_s),\\
%		\max\limits_{k\in 1,\dots,|N^+(v)|}\{k+\sigma(j_k):j_k\in N^+(v)\wedge \forall \ell<k:\sigma(j_\ell)>\sigma(j_k)\},\\
%		\hfill \text{ if }v\in V_s\setminus L(T_s).
%
%\end{cases}\;
%$
%}
%\Return $\max_{s\in S}\sigma(s)$\;
%%\Return $\lceil k/s \rceil$\;
% \caption{A method for determining an upper bound}
%\label{alg:genub}
%\end{algorithm}
%The algorithm consists of two phases. 
%In the first phase (lines 3 -- 10), $m$ broadcast trees are constructed.
%The second phase (lines 11 -- 13) uses a recursive formula that determines in linear time an optimal broadcast time for a subtree of $T_s$ rooted at $v\in V_s$.
%The value  $\sigma(s)$ than gives the optimal broadcast time for $T_s$.
%The complexity of Alg. \ref{alg:genub} depends on the strategy according to which the trees are constructed.
%For common strategies such as BFS and DFS it is $\mathcal{O}(n+|E|)$, for the shortest paths trees $\mathcal{O}(|E| + n\log n)$.
%
%
